#+title:  i3 literate configuration file
#+author: emil lenz
#+email:  emillenz@protonmail.com
#+date:   [2023-05-15] <- ([2024-11-15] version: marks & literate style)
#+property: header-args:conf :tangle config

* preface
- [[https://i3wm.org/docs/userguide.html][i3 user-guide]]
- doing changes in system (eg. volume change / internet connection change) are displayed via notifications.  so we don't need the statusbar (only for leadermode indication) for a more focused workflow and more/clean screenspace.
- i3 exhibits the usual elitism amongst minimal window managers: don’t be bloated, don’t be fancy (simple borders are the most decoration it has).  do not add further complexity when it can be avoided.
- manual tiling wm ::  which superior to an autotiling wm, (or god forbid a desktop-environment), since we always use all windows maximized.
- the windowmanager follows the philosopy of eliminating mental overhead and the neccessity to arrange windows or layouts.
  - eliminate mental overhead and reduce computational steps to get to where you need to be.
  - finetuned to automate the workflow as much as possible. (autostarting all frequently used programs, pinning frequently used browser tabs to [[kbd:][M-<num>]])
- accessing a program is as efficient as possible and always consistent, no matter where in your desktop you are (different monitor/workspace/app order) you will not alt+tab through apps to get to the one you are thinking of.  instead the program is assigned a mark which you can goto to always using the same consisten mnemonic keybinding.
  - we do not use a per-program workspace workflow.  introduces layers of complexity as you need to remember the workspace for pop-up windows & programs.  managing and navigating the workspaces is disorienting and complex.
  - we essentially extend our emacs/vim workflow of using harpoon to jump between files onto the wm, using global marks to goto to buffers immediately.  the only improvement is that we always preassign certain marks for our frequently used programs (editor, webbrowser, terminal, ...).
- keyboard driven workflow only => vi-mnemonic bindings.  has a leader key system inbuilt that allows a extensible modal keybindingsystem.
- strictly avoid multitasking => always work in maximized-mode to never have to resize a window => one workspace per window, to not get distracted by other open windows.
- if at work and forced to use a desktop environment, just use [[kbd:][M-<tab>]] to switch windows and resize your emacs/webbrowser in a similar fashion to get 90% of the benefits of i3.
- we use i3's leadermode in combination with ~dmenu~ to extend our efficient, extensible and fast emacs workflow of using global keybindings in leadermode and minibuffer prompts for interactive commands & input.  dmenu is visually and functionally similar to emacs minibuffer (also in flat mode, same keybindings).

** single monitor only
:PROPERTIES:
:created: [2024-05-21 Tue 11:38]
:END:
- we don't have/use multiple monitors.  instead just get used to the efficient & fast navigation- to navigate within virtual workspaces (using a window manager) which is faster (than physically reorienting your FOV) more extensible (have as many as you need), and more consistent (always available, even when on laptop).
- this is consistent with the navigational workflow inside emacs, where we also never use splits and instead use the current window.
- managing windows over multiple monitors becomes increasingly complex and produces overhead.  it's faster to switch to the window you need instantaneously with a keyboard shortcut, instead of physically tilting the head (which is also unergonomic).  additionally we want consistency in the workflow inbetween using the laptop and desktop setup (if you even have that).
- using a single monitor only not only makes you faster, but it also aligns with the focused singletasking fullscreen workflow.
- hence we don't include any bindings to move workspaces/windows between outputs.

* macros
- no statusbar => using notifications to display volume change
#+begin_src conf
set $MV move container to workspace
set $SHCMD exec --no-startup-id
set $LSHCMD exec mode "default"; --no-startup-id
set $START_SHCMD exec_always --no-startup-id
set $DMENU_THEME -b -i -fn 'Iosevka Comfy-10' -nb '#ffffff' -nf '#000000' -sb '#c0deff' -sf '#000000'
set $BIN ~/.local/bin

set $VOL_INC pamixer --unmute --increase 5 && dunstify --replace 69 "vol: $(pamixer --get-volume-human)"
set $VOL_DEC pamixer --unmute --decrease 5 && dunstify --replace 69 "vol: $(pamixer --get-volume-human)"
set $VOL_MUTE pamixer --toggle-mute && dunstify --replace 69 "vol: $(pamixer --get-volume-human)"
set $MIC_MUTE pamixer --default-source --toggle-mute && dunstify --replace 69 "mic-mute: $(pamixer --default-source --get-mute)"
set $PLAYERCTL_PLAY_PAUSE playerctl play-pause && dunstify --replace 69 "$(sleep 0.1 && playerctl status)"

set $SYS_SLEEP i3lock --color ffffff && systemctl suspend
set $SYS_SCREENOFF sleep 1 && xset dpms force off
set $SYS_HIBERNATE systemctl hibernate
#+end_src

* start processes
- ensure these programs/daemon's are always running
#+begin_src conf
$START_SHCMD emacsclient --reuse-frame || (emacs --daemon && emacsclient --create-frame)
$START_SHCMD pgrep firefox || firefox
$START_SHCMD pgrep playerctld || playerctld
$START_SHCMD pgrep unclutter || unclutter
$START_SHCMD pgrep batsignal || batsignal -bpe -w 50 -c 20 -d 5
$START_SHCMD pgrep nm-applet || nm-applet
#+end_src

- background :: minimalist modus-vivendi bg color
#+begin_src conf
$START_SHCMD xsetroot -solid '#ffffff'
#+end_src

no auto screensaving/powersaving (annoying when studying).  when we want the screen off, we do it manually.
#+begin_src conf
$START_SHCMD xset dpms 0 0 0
$START_SHCMD xset s off
#+end_src

keyremaps + disable key repeat (efficiency!)
#+begin_src conf
$START_SHCMD pgrep xremap || xremap --watch=config ~/.config/xremap/config.yml
$START_SHCMD xset r off
#+end_src

* opts
- minimalist borders
- force all windows into tabbed mode, never allow floating windows.
- no widow icons (bloat)
#+begin_src conf
workspace_auto_back_and_forth no
workspace_layout tabbed
force_focus_wrapping no
default_orientation horizontal
# <pixel> hides titlebars when it's the only window on the workspace
default_border pixel 1
hide_edge_borders smart_no_gaps
title_align left
font pango: Iosevka Comfy 10
focus_on_window_activation focus
smart_gaps inverse_outer
#+end_src

* keybindings
- MOD = [[kbd:][alt]] :: this is ergnomic for laptops and custom keyboards alike.  we otherwise don't need [[kbd:][alt]], since we only use [[kbd:][ctrl]] within applications (and don't use emacs keys).
- disable mousewheel functionality :: no accidental window switching wheen mouse is still on titlebar
- accessibility :: we map XF86 keys for large keyboards & laptops, but most functions also available without taking the hands off the keyboards (or if minimalist keyboard without XFkeys)

#+begin_src conf
set $MOD Mod1
floating_modifier $MOD
# we don't tile
tiling_drag off
bindsym button2 kill
bindsym --whole-window $MOD+button2 floating toggle
bindsym button4 nop
bindsym button5 nop

bindsym XF86MonBrightnessDown $SHCMD brightnessctl set 5%-
bindsym XF86MonBrightnessUp $SHCMD brightnessctl set 5%+
# to reset screenlayouts when disconnecting laptop from external output
bindsym XF86Display $SHCMD xrandr --auto
bindsym XF86ScreenSaver $SHCMD $SYS_SCREENOFF
bindsym XF86Sleep $SHCMD $SYS_SLEEP
bindsym XF86AudioPlay $SHCMD $PLAYERCTL_PLAY_PAUSE
bindsym XF86AudioPause $SHCMD $PLAYERCTL_PLAY_PAUSE
bindsym XF86AudioNext $SHCMD playerctl next
bindsym XF86AudioPrev $SHCMD playerctl previous
bindsym XF86AudioLowerVolume $SHCMD $VOL_DEC
bindsym XF86AudioRaiseVolume $SHCMD $VOL_INC
bindsym XF86AudioMute $SHCMD $VOL_MUTE
bindsym XF86AudioMicMute $SHCMD $MIC_MUTE

bindsym $MOD+minus $SHCMD $VOL_DEC
bindsym $MOD+equal $SHCMD $VOL_INC
bindsym $MOD+bracketright $SHCMD playerctl next
bindsym $MOD+bracketleft $SHCMD playerctl previous
bindsym $MOD+backslash $SHCMD $PLAYERCTL_PLAY_PAUSE
#+end_src

* navigational bindings
- use [[kbd:][MOD+shift+h/l]] to vsplit a window when needing to view things side-by-side.
- dmenu :: you can pass flags/args to programs as neccessary (eg. ~emacs -Q~)
#+begin_src conf
bindsym $MOD+p focus left
bindsym $MOD+shift+p move left
bindsym $MOD+n focus right
bindsym $MOD+shift+n move right
bindsym $MOD+q kill

# find window (using xargs to abort if none picked)
bindsym $MOD+f $SHCMD wmctrl -l | cut --delimiter=' ' --fields='5-' | dmenu $DMENU_THEME -p 'window >' | xargs --delimiter='\n' wmctrl -a

bindsym $MOD+Tab workspace back_and_forth
bindsym $MOD+Return $SHCMD i3-dmenu-desktop --dmenu="dmenu -p 'desktop-run >' $DMENU_THEME"
bindsym $MOD+shift+Return $SHCMD dmenu_run -p 'run > ' $DMENU_THEME
#+end_src

* gaps
we only ever use a single window (no splits) in our editor/terminal, thus for text-based programs (editor/terminal...) ::
- constrain window-width and center windows to the middle of the screen.  whereas normally they are offset to the left edge of the screen.  whereas other windows contents (like the browser) are already ergonomically centered and constrained, which causes you to refocus the fov from the edge to the center of the window (& vice versa).
- this makes our single-focus workflow more ergonomic and focused.
- no long lines ::
  - improved readability & focus of textparagraphs, especially if you stare at the computer for 8+ hours a day.
  - the displayed data is more compact and coherent
  - reading code/data/formulas, and vertical vim navigation, is easier top to bottom vs horizontally.
    - take math as example, its easier to read equations if they are short, concise and aligned on a newline, rather than in one long equation.
    - coding: typically one (short) statement per line.
- line wrap :: command outputs or browser webpages are often not fixed to some width, instead displayed across the entire available width, thus making it very hard to not loose focus of the current line.  using gaps, it makes the text easier to read.
- no manual adjustment :: you should never manually resize gaps, find an optimal setting for your setup (hence the lack of bindings).  in special cases you may toggle fullscreen to get rid of gaps.

#+begin_src conf
# 1920x1080 display, size fits a 100 wide fill-column textbuffer (+ margins) optimally.
set $GAPSIZE 500
bindsym $MOD+z gaps horizontal current toggle $GAPSIZE
#+end_src

* workspaces
- the idea is to bind to the abstract function of the program, and not to the specific instance itself => if a different program is used, the functionality and bindings remain the same.  (eg: vim instead of emacs).
- if you are forced to work with a desktop environment, you can easily replicate this config by manually putting clients on separate workspaces and using [[kbd:][MOD+<number>]] to switch.
- workspace assigned programs are started automatically by the ~autostart~ script and a binding to open them client-server style when it makes sense (if accidentally closed), all other apps are to be opened via dmenu desktop laucher.  ensuring these programs are always running just reduces mental overhead and startup time.
- the parenthesis around the commands are required, otherwise undefined behaviour.
- get window title & class information using: ~xprop~
- for windows that are not assigned to workspaces it is most efficient to use the dmenu ~window-menu~.
- workspaces are powerful, since they allow multiple windows of the same class to be opened on the same workspace (eg. multiple instances of zathura).  and they allow per window gaps/fullscreen configuration.

#+name: workspaces
#+begin_src elisp
(let ((workspaces '(;; ("name" "wmclass" "startcmd" "use-gaps?")

                    ;; windows not assigned to their own workspaces
                    ("all"
                     ".")

                    ("edit"
                     "Emacs"
                     "emacsclient --reuse-frame || (emacs --daemon && emacsclient --create-frame)"
                     t)

                    ("read"
                     "Zathura"
                     nil)

                    ("web"
                     "firefox"
                     "firefox"))))

  (mapconcat (lambda (tuple)
               (let* ((name (nth 0 tuple))
                      (key (char-to-string (aref name 0)))
                      (class (nth 1 tuple))
                      (cmd (nth 2 tuple))
                      (gaps-flag (nth 3 tuple)))

                 (mapconcat #'identity
                            (remove nil (list (format "# WORKSPACE: %s" (upcase name))

                                              (when gaps-flag
                                                (format "workspace %s gaps horizontal $GAPSIZE"
                                                        name))

                                              (format "for_window [class=\"%s\"] move container to workspace %s"
                                                      class
                                                      name)

                                              (format "bindsym $MOD+%s workspace %s"
                                                      key
                                                      name)

                                              (when cmd (format "bindsym $MOD+shift+%s exec --no-startup-id %s" key cmd))))
                            "\n")))
             workspaces
             "\n\n"))
#+end_src

(read: ~M-x info-display-manual org~ chapter: =16 working with source code=, if you don't know what this magic is doing)
#+begin_src conf
# WORKSPACE: ALL
for_window [class="."] move container to workspace all
bindsym $MOD+a workspace all

# WORKSPACE: EDIT
workspace edit gaps horizontal $GAPSIZE
for_window [class="Emacs"] move container to workspace edit
bindsym $MOD+e workspace edit
bindsym $MOD+shift+e exec --no-startup-id emacsclient --reuse-frame || (emacs --daemon && emacsclient --create-frame)

# WORKSPACE: READ
for_window [class="Zathura"] move container to workspace read
bindsym $MOD+r workspace read

# WORKSPACE: WEB
for_window [class="firefox"] move container to workspace web
bindsym $MOD+w workspace web
bindsym $MOD+shift+w exec --no-startup-id firefox

# HACK :: must come last to apply to all workspaces.
for_window [all] focus, title_window_icon no
#+end_src

* leader
- bind infrequently used commands and menus
- ~kill-menu~ :: gives a overview of running processes and allows you to interactively kill one (you don't need htop).
#+begin_src conf
bindsym $MOD+space mode "leader"

mode "leader" {
	bindsym $MOD+a $LSHCMD $BIN/audio-output-menu $DMENU_THEME
	bindsym $MOD+b $LSHCMD $BIN/bluetooth-menu $DMENU_THEME
	bindsym $MOD+k $LSHCMD $BIN/kill-menu $DMENU_THEME
	bindsym $MOD+d $LSHCMD sh $HOME/.screenlayout/$(ls $HOME/.screenlayout | dmenu -p 'screenlayout > ' $DMENU_THEME)

	# screenshot
	bindsym $MOD+s $LSHCMD scrot --select --file "$HOME/Pictures/screenshots/%Y-%m-%d_T%H-%M-%S.png" --exec 'dunstify "screenshot" "$f"'

	bindsym $MOD+e $LSHCMD emacsclient --eval "(emacs-everywhere)"

	bindsym $MOD+q $LSHCMD $SYS_SLEEP
	bindsym $MOD+shift+q $LSHCMD $SYS_HIBERNATE
	bindsym $MOD+o $LSHCMD $SYS_SCREENOFF

	bindsym $MOD+m $LSHCMD $VOL_MUTE
	bindsym $MOD+shift+m $LSHCMD $MIC_MUTE

	bindsym Escape mode "default"
}
#+end_src

* modus-operandi theme
#+begin_src conf
set $BG          #ffffff
set $FG          #000000
set $MODELINE_BG #c8c8c8
set $BORDER      #9f9f9f
set $ACTIVE_BG   #c0deff
set $URGENT_BG   #ff8f88

## element              $border    $bg          $fg $mark $border (child)
client.focused          $ACTIVE_BG $ACTIVE_BG   $FG $FG   $ACTIVE_BG
client.focused_inactive $BORDER    $MODELINE_BG $FG $FG   $BORDER
client.unfocused        $BORDER    $MODELINE_BG $FG $FG   $BORDER
client.urgent           $URGENT_BG $URGENT_BG   $FG $FG   $URGENT_BG
client.background       $BG
#+end_src

* modeline
** modeline / tabbar
- a wm statusbar unneccessarily take up screen real-estate and usually just causes a distraction rather than actually being useful.
  - you don't need visual indication of how to navigate to tabs, each specific tab is always on the same keybind, and if not it's faster to search for it than visually navigate/select some list / menu.
- for full immersion, reduced distraction and enhanced focus, disable it and work fullscreen.
  - no overlapping functionality.  ex:: you wear a watch (if not, you should) => don't need time & date displayed, and have timer's at hand.
  - you always know what window you are looking at by its contents.
  - you don't need visual indication of how to navigate to tabs, nor interact with the statusbar (ex: click something) => each specific tab is always on the same keybind.
- the aestetic and efficiency of a decluttered and maximized screen is (imo) unmatched.
- the theory is to make switching so ergonomic and instantaneous, engrained into muscle memory, that you are faster that people using, say 2 monitors.
- (modelines are useful (browser / emacs) as they indicate in which mode/context we are in.)

- modline only shown when explicitly toggled and used as a leadermode indicator.
#+begin_src conf
bar {
	mode hide
	workspace_buttons yes
	binding_mode_indicator yes
	modifier none
	tray_output primary
	status_command i3status
	separator_symbol " | "
	workspace_min_width 40

	colors {
		background $MODELINE_BG
		statusline $FG
		separator $FG
		#class             $border      $bg          $fg
		binding_mode       $MODELINE_BG $MODELINE_BG $MODELINE_BG
		focused_workspace  $BORDER      $ACTIVE_BG   $FG
		active_workspace   $BORDER      $MODELINE_BG $FG
		inactive_workspace $BORDER      $MODELINE_BG $FG
		urgent_workspace   $BORDER      $URGENT_BG   $FG
	}
}
#+end_src
