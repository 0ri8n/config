#+title:  i3 literate configuration file
#+author: emil lenz
#+email:  emillenz@protonmail.com
#+date:   2023-05-15
#+info: creation: 2023-05-15, using marks & literate style: 2024-11-15
#+property: header-args:conf :tangle config

* preface
- [[https://i3wm.org/docs/userguide.html][i3 user-guide]]
- doing changes in system (eg. volume change / internet connection change) are displayed via notifications.  so we don't need the statusbar (only for leadermode indication) for a more focused workflow and more/clean screenspace.
- i3 exhibits the usual elitism amongst minimal window managers: don’t be bloated, don’t be fancy (simple borders are the most decoration it has).  do not add further complexity when it can be avoided.
- manual tiling wm ::  which superior to an autotiling wm, (or god forbid a desktop-environment), since we always use all windows maximized.
- the windowmanager follows the philosopy of eliminating mental overhead and the neccessity to arrange windows or layouts.
  - eliminate mental overhead and reduce computational steps to get to where you need to be.
  - finetuned to automate the workflow as much as possible. (autostarting all frequently used programs, pinning frequently used browser tabs to [[kbd:][M-<num>]])
- accessing a program is as efficient as possible and always consistent, no matter where in your desktop you are (different monitor/workspace/app order) you will not alt+tab through apps to get to the one you are thinking of.  instead the program is assigned a mark which you can goto to always using the same consisten mnemonic keybinding.
  - we do not use a per-program workspace workflow.  introduces layers of complexity as you need to remember the workspace for pop-up windows & programs.  managing and navigating the workspaces is disorienting and complex.
  - we essentially extend our emacs/vim workflow of using harpoon to jump between files onto the wm, using global marks to goto to buffers immediately.  the only improvement is that we always preassign certain marks for our frequently used programs (editor, webbrowser, terminal, ...).
- keyboard driven workflow only => vi-mnemonic bindings.  has a leader key system inbuilt that allows a extensible modal keybindingsystem.
- strictly avoid multitasking => always work in maximized-mode to never have to resize a window => one workspace per window, to not get distracted by other open windows.
- if at work and forced to use a desktop environment, just use [[kbd:][M-<tab>]] to switch windows and resize your emacs/webbrowser in a similar fashion to get 90% of the benefits of i3.

* macros
- no statusbar => using notifications to display volume change
#+begin_src conf
set $ESC mode "default"
set $BIN ~/Dotfiles/bin
set $MV move container to workspace
set $SHCMD exec --no-startup-id
set $ROFI rofi -dmenu -no-custom -i -p find-file

set $VOL_INC pamixer --unmute --increase 5 && dunstify --replace 69 "vol: $(pamixer --get-volume-human)"
set $VOL_DEC pamixer --unmute --decrease 5 && dunstify --replace 69 "vol: $(pamixer --get-volume-human)"
set $VOL_MUTE pamixer --toggle-mute && dunstify --replace 69 "vol: $(pamixer --get-volume-human)"
set $MIC_MUTE pamixer --default-source --toggle-mute && dunstify --replace 69 "mic-mute: $(pamixer --default-source --get-mute)"
set $PLAYERCTL_PLAY_PAUSE playerctl play-pause && dunstify --replace 69 "$(sleep 0.1 && playerctl status)"

set $SYS_SLEEP i3lock --color ffffff && systemctl suspend
set $SYS_SCREENOFF sleep 1 && xset dpms force off
set $SCROT scrot --file "$HOME/Pictures/screenshots/%Y-%m-%d_T%H-%M.png" --exec 'dunstify "screenshot" "$f" && echo $f | xclip -selection=clipboard'
#+end_src

* autostart
start daemons (emacs, tmux), run startup commands, etc.
#+begin_src conf
exec_always --no-startup-id $BIN/autostart &
#+end_src

* opts
- minimalist borders
- force all windows into tabbed mode, never allow floating windows.
- no widow icons (bloat)
#+begin_src conf
workspace_auto_back_and_forth no
workspace_layout tabbed
force_focus_wrapping no
default_orientation horizontal
# <pixel> hides titlebars when it's the only window on the workspace
default_border pixel 1
hide_edge_borders smart_no_gaps
title_align left
font pango: Iosevka Comfy 10
focus_on_window_activation focus
smart_gaps inverse_outer
#+end_src

* keybindings
- mod1 = alt (ergonomic)
- disable mousewheel functionality :: no accidental window switching wheen mouse is still on titlebar
- accessibility :: we map XF86 keys for large keyboards & laptops, but most functions also available without taking the hands off the keyboards (or if minimalist keyboard without XFkeys)

#+begin_src conf
set $MOD Mod1
floating_modifier $MOD
# we don't tile
tiling_drag off
bindsym button2 kill
bindsym --whole-window $MOD+button2 floating toggle
bindsym button4 nop
bindsym button5 nop

bindsym XF86MonBrightnessDown $SHCMD brightnessctl set 5%-
bindsym XF86MonBrightnessUp   $SHCMD brightnessctl set 5%+
bindsym XF86Display           $SHCMD xrandr --auto
bindsym XF86ScreenSaver       $SHCMD $SYS_SCREENOFF
bindsym XF86Sleep             $SHCMD $SYS_SLEEP
bindsym XF86AudioPlay         $SHCMD $PLAYERCTL_PLAY_PAUSE
bindsym XF86AudioPause        $SHCMD $PLAYERCTL_PLAY_PAUSE
bindsym XF86AudioNext         $SHCMD playerctl next
bindsym XF86AudioPrev         $SHCMD playerctl previous
bindsym XF86AudioLowerVolume  $SHCMD $VOL_DEC
bindsym XF86AudioRaiseVolume  $SHCMD $VOL_INC
bindsym XF86AudioMute         $SHCMD $VOL_MUTE
bindsym XF86AudioMicMute      $SHCMD $MIC_MUTE

bindsym $MOD+9            $SHCMD $MIC_MUTE
bindsym $MOD+0            $SHCMD $VOL_MUTE
bindsym $MOD+minus        $SHCMD $VOL_DEC
bindsym $MOD+equal        $SHCMD $VOL_INC
bindsym $MOD+bracketright $SHCMD playerctl next
bindsym $MOD+bracketleft  $SHCMD playerctl previous
bindsym $MOD+backslash    $SHCMD $PLAYERCTL_PLAY_PAUSE
#+end_src

* navigational bindings
- use MOD+shift+{h/l} to vsplit a window when needing to view things side-by-side.
#+begin_src conf
bindsym $MOD+h          focus left
bindsym $MOD+shift+h    move left
bindsym $MOD+l          focus right
bindsym $MOD+shift+l    move right
bindsym $MOD+q          kill
bindsym $MOD+b          $SHCMD rofi -show window
bindsym $MOD+semicolon  $SHCMD rofi -show drun
bindsym $MOD+Return     move workspace to output next
bindsym $MOD+Tab        workspace back_and_forth

# not really used, but just for vim compatibility.
bindsym $MOD+m          $SHCMD i3-input -l 1 -F 'mark %s'
bindsym $MOD+apostrophe $SHCMD i3-input -l 1 -F '[con_mark="%s"] focus'
#+end_src

* gaps
we only ever use a single window (no splits) in our editor/terminal, thus for text-based programs (editor/terminal...) ::
- constrain window-width and center windows to the middle of the screen.  whereas normally they are offset to the left edge of the screen.  whereas other windows contents (like the browser) are already ergonomically centered and constrained, which causes you to refocus the fov from the edge to the center of the window (& vice versa).
- this makes our single-focus workflow more ergonomic and focused.
- no long lines ::
  - improved readability & focus of textparagraphs, especially if you stare at the computer for 8+ hours a day.
  - the displayed data is more compact and coherent
  - reading code/data/formulas, and vertical vim navigation, is easier top to bottom vs horizontally.
    - take math as example, its easier to read equations if they are short, concise and aligned on a newline, rather than in one long equation.
    - coding: typically one (short) statement per line.
- line wrap :: command outputs or browser webpages are often not fixed to some width, instead displayed across the entire available width, thus making it very hard to not loose focus of the current line.  using gaps, it makes the text easier to read.
- no manual adjustment :: you should never manually resize gaps, find an optimal setting for your setup (hence the lack of bindings).  in special cases you may toggle fullscreen to get rid of gaps.

#+begin_src conf
# 1920x1080 display, size fits a 100 wide fill-column textbuffer (+ margins) optimally.
set $GAPSIZE 500
bindsym $MOD+z gaps horizontal current toggle $GAPSIZE
#+end_src

* workspaces
- the idea is to bind to the abstract function of the program, and not to the specific instance itself => if a different program is used, the functionality and bindings remain the same.  (eg: vim instead of emacs).
- if you are forced to work with a desktop environment, you can easily replicate this config by manually putting clients on separate workspaces and using [[kbd:][MOD+<number>]] to switch.
- workspace assigned programs are started automatically by the ~autostart~ script and a binding to open them client-server style when it makes sense (if accidentally closed), all other apps are to be opened via rofi desktop laucher.  ensuring these programs are always running just reduces mental overhead and startup time.
- the parenthesis around the commands are required, otherwise undefined behaviour.
- get window title & class information using: ~xprop~
- for windows that are not assigned to workspaces it is most efficient to use the rofi find-window menu.
- workspaces are powerful, since they allow multiple windows of the same class to be opened on the same workspace (eg. multiple instances of zathura).  and they allow per window gaps/fullscreen configuration.

#+name: workspaces
#+begin_src elisp
(let ((workspaces '(;; ("name" "wmclass" "startcmd" "use-gaps?")

                    ;; windows not assigned to their own workspaces
                    ("all"
                     ".")

                    ("term"
                     "Alacritty"
                     "alacritty --title term --command tmux new-session -A -s main"
                     t)

                    ("edit"
                     "Emacs"
                     "emacsclient --reuse-frame || (emacs --daemon && emacsclient --create-frame)"
                     t)

                    ("read"
                     "Zathura"
                     nil)

                    ("web"
                     "firefox"
                     "firefox"))))

  (mapconcat (lambda (tuple)
               (let* ((name (nth 0 tuple))
                      (key (char-to-string (aref name 0)))
                      (class (nth 1 tuple))
                      (cmd (nth 2 tuple))
                      (gaps-flag (nth 3 tuple)))

                 (mapconcat #'identity
                            (remove nil (list (format "# WORKSPACE: %s" (upcase name))

                                              (when gaps-flag
                                                (format "workspace %s gaps horizontal $GAPSIZE"
                                                        name))

                                              (format "for_window [class=\"%s\"] move container to workspace %s"
                                                      class
                                                      name)

                                              (format "bindsym $MOD+%s workspace %s"
                                                      key
                                                      name)

                                              (when cmd (format "bindsym $MOD+shift+%s exec --no-startup-id %s" key cmd))))
                            "\n")))
             workspaces
             "\n\n"))
#+end_src

#+RESULTS[3ce1064a1beacc21856743d63ee482ba4fafae3a]: workspaces
#+begin_example
# WORKSPACE: ALL
for_window [class="."] move container to workspace all
bindsym $MOD+a workspace all

# WORKSPACE: TERM
workspace term gaps horizontal $GAPSIZE
for_window [class="Alacritty"] move container to workspace term
bindsym $MOD+t workspace term
bindsym $MOD+shift+t exec --no-startup-id alacritty --title term --command tmux new-session -A -s main

# WORKSPACE: EDIT
workspace edit gaps horizontal $GAPSIZE
for_window [class="Emacs"] move container to workspace edit
bindsym $MOD+e workspace edit
bindsym $MOD+shift+e exec --no-startup-id emacsclient --reuse-frame || (emacs --daemon && emacsclient --create-frame)

# WORKSPACE: READ
for_window [class="Zathura"] move container to workspace read
bindsym $MOD+r workspace read

# WORKSPACE: WEB
for_window [class="firefox"] move container to workspace web
bindsym $MOD+w workspace web
bindsym $MOD+shift+w exec --no-startup-id firefox
#+end_example

(read: ~M-x info-display-manual org~ chapter: =16 working with source code=, if you don't know what this magic is doing)
#+begin_src conf
<<workspaces()>>

# HACK :: must come last to apply to all workspaces.
for_window [all] focus, title_window_icon no, floating disable
#+end_src

* leader
- bind infrequently used commands and menus
#+begin_src conf

bindsym $MOD+space mode "leader"
mode "leader" {
        bindsym $MOD+a $SHCMD $BIN/audio-output-menu; $ESC
        bindsym $MOD+b $SHCMD $BIN/bluetooth-menu; $ESC
        bindsym $MOD+k $SHCMD $BIN/killprocess-menu; $ESC
        bindsym $MOD+d $SHCMD sh $HOME/.screenlayout/$(fd '.' --base-directory $HOME/.screenlayout | $ROFI); $ESC

        bindsym --release $MOD+s $SHCMD $SCROT --select; $ESC
        bindsym $MOD+shift+s $SHCMD $SCROT; $ESC

        bindsym $MOD+e $SHCMD emacsclient --eval "(emacs-everywhere)"; $ESC

        bindsym $MOD+m $SHCMD mpv "$(xclip -out)"; $ESC

        bindsym $MOD+q $SHCMD $SYS_SLEEP; $ESC
        bindsym $MOD+o $SHCMD $SYS_SCREENOFF; $ESC

        bindsym Escape mode "default"
}
#+end_src

* modus-operandi theme
#+begin_src conf
set $BG          #ffffff
set $FG          #000000
set $MODELINE_BG #c8c8c8
set $BORDER      #9f9f9f
set $ACTIVE_BG   #c0deff
set $URGENT_BG   #ff8f88

## element              $border    $bg          $fg $mark $border (child)
client.focused          $ACTIVE_BG $ACTIVE_BG   $FG $FG   $ACTIVE_BG
client.focused_inactive $BORDER    $MODELINE_BG $FG $FG   $BORDER
client.unfocused        $BORDER    $MODELINE_BG $FG $FG   $BORDER
client.urgent           $URGENT_BG $URGENT_BG   $FG $FG   $URGENT_BG
client.background       $BG
#+end_src

* modeline
** modeline / tabbar
- a wm statusbar unneccessarily take up screen real-estate and usually just causes a distraction rather than actually being useful.
  - you don't need visual indication of how to navigate to tabs, each specific tab is always on the same keybind, and if not it's faster to search for it than visually navigate/select some list / menu.
- for full immersion, reduced distraction and enhanced focus, disable it and work fullscreen.
  - no overlapping functionality.  ex:: you wear a watch (if not, you should) => don't need time & date displayed, and have timer's at hand.
  - you always know what window you are looking at by its contents.
  - you don't need visual indication of how to navigate to tabs, nor interact with the statusbar (ex: click something) => each specific tab is always on the same keybind.
- the aestetic and efficiency of a decluttered and maximized screen is (imo) unmatched.
- the theory is to make switching so ergonomic and instantaneous, engrained into muscle memory, that you are faster that people using, say 2 monitors.
- (modelines are useful (browser / emacs) as they indicate in which mode/context we are in.)

- modline only shown when explicitly toggled and used as a leadermode indicator.
#+begin_src conf
bar {
        mode hide
        workspace_buttons yes
        binding_mode_indicator yes
        modifier none
        tray_output primary
        status_command i3status
        separator_symbol " | "
        workspace_min_width 40

        colors {
                background $MODELINE_BG
                statusline $FG
                separator  $FG
                #class             $border      $bg          $fg
                binding_mode       $MODELINE_BG $MODELINE_BG $MODELINE_BG
                focused_workspace  $BORDER      $ACTIVE_BG   $FG
                active_workspace   $BORDER      $MODELINE_BG $FG
                inactive_workspace $BORDER      $MODELINE_BG $FG
                urgent_workspace   $BORDER      $URGENT_BG   $FG
        }
}
#+end_src
