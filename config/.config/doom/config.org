#+title:  doom emacs config
#+author: emil lenz
#+email:  emillenz@protonmail.com
#+date:   2022-11-01
#+info:   heavily opinionated config, with a principle-focused approach on: consistency, quality, efficiency & extensibility.

#+property: header-args:elisp tangle config.el :comments link :results silent
#+macro: src-len (eval (save-excursion (find-file doom-module-config-file) (count-lines (point-min) (point-max))))

* about this config
- a total of {{{src-len}}} LOC.
- for debugging your configuration, start emacs with: ~emacs --debug-init~ to get a backtrace.  when debuggin lisp code, enable ~toggle-debug-on-error~ and eval the code.
- read up on and adhere to [[https://github.com/bbatsov/emacs-lisp-style-guide][emacs-lisp style guide]].
- user defined global functions and variables are prefixed with ~u-~ (~user~) to distinguish them from emacs/library ones.
- lazyload packages using ~after!~.  this keeps emacs efficent, since it now only loads the settings & packages when they are actually needed (no emacs bankruptcy).
- i believe that customizations are personal and should not be blindly copied.  Everyone should carefully consider each customizable setting they hear about and decide for themselves whether they like it or not.  Non-trivial customizations that include Lisp code should be fully understood before they are accepted, rejected, or amended to personal taste.  (read the manual)
  - i encourage you to master the tool that you are using.  this means thuroughly reading the complete documentation, keymaps for the tools you are using (eg. vertico, evil-mode, magit, leader-mode).
  - try to first fundamentally understand & master the functionality your tool offers.  then you can assess and see if a extension really provides value to you, or if that functionality is already included.
- use ~use-package!~ for configuring packages added via ~package!~ in ~./packages.el~
- to debug, start emacs with ~emacs --debug-init~ and use ~emacs --no-init-file~ to fix the errors.
- viper mode :: use it if it's not feasible to install the full doom-config (eg. using emacs on another computer).  never use original vim if you have emacs installed.
  - you should never use ~:ex~ commands and instead use the native ~M-x~ and ~C-x / C-c~ bindings that emacs provides for a more consistent experience.
    - viper provides you 80% of evil-mode's ergonomics with the unlimited power of emacs.

* preface
** why emacs
#+begin_quote
Today, many aspects of daily computer usage are split between different applications which act like islands, but this often doesn’t mirror how we actually use our computers.  Emacs, if one goes down the rabbit hole, can give users the power to bridge this gap into a visually and functionally consistent environment.

Professional, minimalist tools like Emacs have a high learning curve and require thought and time to initially set up.  But once things are working and customized they will work for years at a stretch without needing to fiddle with the nobs.  And once mastered you can eliminate the "modern" GUI bits -- tool bars, menus, scrollbars and fancy animations and the like and what is left is about as clean an interface as you can get stripping everything down to the bare metal where it gets out of your way and provides the most streamlined workflow.  The difference is that something like emacs is a longterm investment, it requires you to get over the high entry barrier but then never annoys you with a more elongated, bloated workflow that in other, more beginner friendly applications is the norm and cannot be changed away from.

The saying, "give 'em enough rope, and they'll likely hang themselves," holds true.  Emacs provides the rope if you are not careful.
--- anonymous
#+end_quote

emacs is one of the most incredible piece of software ever made:
- purely keyboard driven.
- everything is text and can be modified.
- enables one to complete tasks with a consistent, standard set of keybindings, gui and editing methods - learn once, use everywhere
- compressing the stages of a project - a more centralised workflow can progress with greater ease
- integration between tasks previously relegated to different applications, but with a common subject - e.g.  linking to an email in a to-do list etc
- emacs can be thought of as a platform within which various elements of your workflow may settle, while being able to interlink them interactively.
- reduced context-switching, many tools in one connected, coherent, interwoven keyboard-driven interface.  this integration is very efficient and consistent, since now any function can be reused in all tools (eg.  fuzzy finding, and doesn't have to be implemented in each separate program itself).  it greatly reduces the mental overhead needed to customize and extend the tools, since the context and language is always the same.  since these tools are text-centric, they align withthe single focus, no multitasking buffer wokflow philosophy.
  - editor
    - technical documents :: latex & org
    - academic papers
    - code
    - notes
    - journaling
  - coding tools
    - git interface :: magit
    - manpages
    - diff
    - debugger
  - agenda
  - emailclient
  - todo-management :: org mode
  - filemanager :: dired fast interactive text-based file manger
  - manpager
  - file/dir navigation & management: find-file, fuzzy-find, (book)marks, dired
    - the most efficient workflow for finding, opening and editing files on the os that i have ever developed.

*** org mode
- in my opinion the most elegant markup language, all the while keeping the syntax opinionated and simple with only one way to do it (=> looking at you: markdown with your weird spacing rules and arcane markup for links/quotes).
- one to rule them all, create websites, tables, journals, todolists, calendars and programs, all with the same consistent elegant and formatted syntax.
- automate making entries into files and databases at specific places.
- completely integrated into the editor (think: finding/filtering headlines, notes, tasks..)
- the best support for literate programming covering every language (looking at you: jupyter..)

*** emacs everywhere
use emacs everywhere for anytime you are using a prompt that requires more than few simple keywords.  eg. chatgpt query, writing a email.  execute emacs-everywhere from i3 (via keybinding) once inside the textfield (or highlighting all text to take over to emacs)

*** downsides
emacs sucks at graphical stuff, hence we use external programs to display pdfs and media.

** emacs as your computing evironment (and your repl/terminal)
- extend emacs by writing custom functions for things that you do repetitivly (moving files, manipulating text...) instead of writing shell aliases / shellscripts
  + more extensible and in a proper language
  + write shell-scripts (purely) for launching programs & processes.
- all coding, writing, fileopening, viewing, navigating is done inside emacs (do not leave the environment), because this makes for a consistent and coherent workflow.  don't jump in and out of the commandline, lauching emacs instances, cd'ing around.
  - use inbuilt programs like magit & diff for more speed interactivity and ergonomics than doing it with git command aliases on the command-line.

** shell: using emacs instead of dedicated terminal
you might be tempted to use a terminal with tmux, zsh/fish, fzf, fancy prompts, bat, exa, and pages filled with git aliases configured.  this results in great complexities and inconsistencies (trying to get the same keybindings, theme etc.) in your shell and editor.  instead you should shun all these features and focus on emacs.  using emacs you have consistency in bindings between the shell and your editor.  no more juggling tmux and the system clipboard when trying to yank/paste text.  no installing tons of shell-plugins to get better vim emulation in the shell (looking at you *zsh*).  you can seamlessly open and switch between man/help/tldr pages while using the shell.  you can navigate & filter (~occur~, etc...) the shell output (instead of using some hacked up, incomplete and inconsistent vim emulation like tmux).  instead of using cd etc. you can freely use all of emacs navigational capabilities (projectile, recentfiles...) (instead of having to install fzf and other crutches).
your syntax highlighting (including help output etc) is directly inherited from your emacs-theme.
using emacs for shells also has the benefit that you can seamlessly create a buffer to script in as soon as you are doing more than a simple oneliner, then either evaluating that buffer or regions to the shell.

*** workflow
use simple minbuffer based ~async-shell-command~'s in emacs, if that doesn't suffice, open: ~shell~.  especially when programming, start REPL's and interactive environments from within emacs (terminal emulation) in order to have a seamless integration and navigation between running commands in the shell and programmning.  this has the benefit that you can navigate command output like a normal buffer and use the full power of emacs for the prompt editing.

the only reason for you to ever use a terminal is if you need to use a TUI or a completely detached background process (eg. a server).

* user
#+begin_src elisp
(setq user-full-name "emil lenz"
      user-mail-address "emillenz@protonmail.com")
#+end_src

* global options
#+begin_src elisp
(setq initial-scratch-message ""
      delete-by-moving-to-trash t
      bookmark-default-file "~/.config/doom/bookmarks" ;; save bookmarks in config dir (to preserve inbetween newinstalls)
      auto-save-default t
      confirm-kill-emacs nil
      hscroll-margin 0
      scroll-margin 0
      enable-recursive-minibuffers t ;; all of emacs available even if in minibuffer.
      display-line-numbers-type 'visual
      shell-command-prompt-show-cwd t)

(save-place-mode)

(global-subword-mode)

(add-hook! prog-mode-hook #'rainbow-delimiters-mode)

(add-hook! emacs-lisp-mode-hook #'toggle-debug-on-error)

(let ((width 100))

  (setq fill-column width
        async-shell-command-width width
        visual-fill-column-width width))

(global-visual-fill-column-mode)
(global-visual-line-mode)

(add-hook! 'prog-mode-hook ;; HACK :: must disable, since it displays the flycheck inline warnings/errors incorrectly.
  (visual-fill-column-mode -1))

(setq global-auto-revert-non-file-buffers t)
(global-auto-revert-mode)

(advice-add '+default/man-or-woman :override #'man) ;; HACK :: we don't use macos, and +default/man-or-woman doesn't invoke `man' correctly
#+end_src

* ui
** modus-theme
#+begin_src elisp
(use-package! modus-themes
  :config
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-common-palette-overrides `((fg-region unspecified) ;; don't grey out syntax highlighting in active region
                                                (fg-heading-1 fg-heading-0)
                                                (bg-prose-block-contents bg-dim)))

  ;; list of customizeable faces: `(helpful-variable 'modus-themes-faces)`
  (custom-set-faces!
    '(org-list-dt :inherit modus-themes-heading-1)
    `(org-block-begin-line :foreground ,(modus-themes-get-color-value 'prose-metadata))
    '(org-quote :slant italic)

    '(comint-highlight-prompt :weight bold))

  (setq doom-theme 'modus-operandi))
#+end_src

** font
- same font & size set to same as system-wide (browser, gtk, terminal, ...).
- variable-pitch-mode :: only for prose i sometimes use a serif font to become more immersed in the reading experience.  like the modeline & minibuffer, we use the default font for line-numbers (by default not the case).
- font-size :: don't use manual font-size increasing, instead just use ~doom-big-font-mode~ if you need big font for presentation purposes.
- ~simple-html-rendering~ (~shr~) ::  should always use the universally applicable default font since we can't presume the content to be displayed with it.  (it is used for eg. ~devdocs~)
#+begin_src elisp
(setq doom-font (font-spec :family "Iosevka Comfy" :size 13))
(setq doom-variable-pitch-font (font-spec :family "Noto Serif" :size 13))

(set-face-attribute 'line-number nil :inherit 'fixed)

(after! shr
  (setq shr-use-fonts nil))
#+end_src

** modeline
- no overlapping funcionality (time & date is on my physical wrist watch, don't need it in any program (also not wm)).
- very minimal, only displaying what's needed (using (:modeline +light))
#+begin_src elisp
(setq display-battery-mode nil
      display-time-mode nil
      +modeline-height 8
      +modeline-bar-width nil) ;; hide
#+end_src

** window layout & behavior :: single maximized buffer workflow
- single maximized buffer workflow :: we explicitly never use more than a single window (we don't split a window) in the frame, since we can only ever focus on a single thing anyways, and thus in the meantime other windows would clutter the screen distractingly.  additionally using multiple windows introduces additional navigational overhead first having to go to the correct window before using ~switch-to-buffer~, ~harpoon~ etc. managing windows and placing them correctly is complex and inconsistent, some windows recieve focus, other's don't, some buffer's create a split, completely changing window layout, others don't.  instead of using windows, you should become really efficient at navigating between buffers using ~switch-to-buffer~, ~evil-switch-to-windows-last-buffer~, ~harpoon~ and evil's ~global-marks~.  it is more efficiet to just change the buffer in the current window, instead of getting disrupted by the newly opened window and having to change your eyes focus.  read more at [[file:~/.config/readme.org][readme.org]].
- only horizontal split :: since emacs sometimes creates splits in special views (eg. magit, ediff) or for displaying additional information (lsp-help...), and thus we must handle them to consistently split below and never side-by-side, since due to the wm, our emacs window is in full height but has a constrained width, perfectly sized for displaying source-code / technical documents.

#+begin_src elisp
(setq display-buffer-alist `(;; mini-buffers :: at bottom, consistent with minibuffer prompt, whichkey, etc.  use `doom/window-enlargen' if you need to scroll its contents.
                             (,(rx (seq "*" (or "transient"
                                                (seq "Org " (or "Select" "todo"))
                                                "Agenda Commands"
                                                "doom eval"
                                                "Backtrace"
                                                "lsp-help")))
                              display-buffer-in-side-window
                              (window-parameters . ((mode-line-format . none)))
                              (window-height . fit-window-to-buffer)
                              (side . bottom))

                             ;; default (all buffer's) :: replace existing window (side window is never used by this)
                             ("."
                              display-buffer-same-window))

      switch-to-buffer-obey-display-actions t)

 ;; HACK :: org src ignores 'display-buffer-alist'.  need to set like this
(after! org
  (setq org-src-window-setup 'current-window
        org-agenda-window-setup 'current-window))

 ;; for when commiting, let magit use it's own window layout.
(after! magit
  (setq magit-commit-diff-inhibit-same-window t
        +magit-open-windows-in-direction 'down))

 ;; does not obey `display-buffer-alist'
(after! man
  (setq Man-notify-method 'pushy))
#+end_src

close popup window (eg. ~*lsp-help*~) from the main window with [[kbd:][escape]] in normal mode.
#+begin_src elisp
(add-hook! 'doom-escape-hook #'delete-other-windows)
#+end_src

** indentation
- formatting :: always configure language formatters externally (config-file) to use 8 spaces indentation.
- we need to re-setq some variables in the respective ~mode~ in order for them to take effect.
#+begin_src elisp
(advice-add #'doom-highlight-non-default-indentation-h :override #'ignore)

(defvar u-global-indent-width 8)

(setq-default standard-indent u-global-indent-width
              evil-shift-width u-global-indent-width
              tab-width u-global-indent-width
              org-indent-indentation-per-level u-global-indent-width
              evil-indent-convert-tabs t
              indent-tabs-mode nil)

(setq-hook! '(c++-mode-hook
              c-mode-hook
              java-mode-hook)
  tab-width u-global-indent-width
  c-basic-offset u-global-indent-width
  evil-shift-width u-global-indent-width)

(setq-hook! 'ruby-mode-hook
  evil-shift-width u-global-indent-width
  ruby-indent-level u-global-indent-width)
#+end_src

*** rationale
a useful time for a quote from the linux kernel coding standards [1] - exactly the first item in fact:

#+begin_quote
Tabs are 8 characters, and thus indentations are also 8 characters.  There are heretic movements that try to make indentations 4 (or even 2!) characters deep, and that is akin to trying to define the value of PI to be 3.  If you need more than 4 levels of indentation within a function, you’re screwed anyway, and should fix your program.
--- Linus Torvalds
#+end_quote

the 8 space indent cannot exist in isolation.  it has to be coupled with a right-hand side limit of 80 columns.  otherwise, you could just indent yourself off to infinity and there would be no consequences.  an 80 column limit forces you to keep your code within reasonable limits.

the whole idea behind indentation is to clearly define where a block of control starts and ends.  this is the same philosophy applied in ~modus-theme~, where we clearly want to separate elements and enhace legibility & accessibility.  especially when you’ve been looking at your screen for 20 straight hours, you’ll find it a lot easier to see how the indentation works if you have large indentations.  you can look at a function definition from afar and tell easily where it begins & ends even though you cannot read the actual code.  it facilitates reading through a codebase in a more tree-like fashion.

every level of indentation represents a piece of program state the reader has to keep in their head to understand a function.  “in this line, i know line points to the nth line as long as x is not true, but y > z.” 8-character indentations, internal spacing, and the 80-column rule effectively limits you to 4 levels of indentation in a function.  this effectively limits the internal complexity of any give function, which makes the code easier to understand and debug!  so the underlying functionality remains minimal and concise.

in short, 8-char indents make things easier to read, and have the added benefit of warning you when you’re nesting your functions too deep.  heed that warning.

- consistency :: the only reliable, repeatable, transportable way to ensure that indentation remains consistent across viewing environments is to indent you code using only spaces.
- using tabs for indentation and spaces for alignment requires extra care, and a carefully tuned editor setup which understands the semantic difference between the tabs and the spaces which follow.  in any sizeable team, deviations in formatting will creep in.  enforcing it will just be a big waste of time, compared to the simplicity of banishing tabs.

* evil-mode
- evil comes with powerful additions and bindings that are to be discovered: [[~/.config/emacs/modules/editor/evil/README.org::* TODO Usage][evil readme]].  familiarize yourself with them and harness their power.
- evil-magic 'nomagic :: statistically its more sensible to incsearch without regex (if you need it use ~\m~ in search string to enable regex.

~after! evil~ begin
#+begin_src elisp
(after! evil
#+end_src

#+begin_src elisp
(evil-surround-mode)
  (setq evil-want-fine-undo nil
        evil-magic nil
        evil-ex-substitute-global t
        evil-want-C-i-jump t
        evil-want-C-h-delete t
        evil-want-minibuffer t ;; don't loose your powers in the minibuffer
        evil-org-use-additional-insert nil)

(defadvice! u-preserve-point (fn &rest args)
  :around '(anzu-query-replace-regexp
            query-replace-regexp
            +format:region)
  (save-excursion
    (apply fn args)))

 ;; FIXME :: `+fold/previous` disabled, since it crashes emacs. (don't call it by accident via binding)
(advice-add '+fold/previous :override #'ignore)

 ;; HACK :: sometimes cursor stays int normal-mode (even though we are in insert mode).  this fixes the inconsistency.
(setq-hook! 'minibuffer-setup-hook cursor-type 'bar)
#+end_src

- jumplist is for functions that jump out of screen
- don't populate jumplist with fuctions that are executed repeatedly (ex: forward-paragraph)
#+begin_src elisp
(dolist (cmd '(flycheck-next-error
               flycheck-previous-error
               +lookup/definition
               +lookup/references
               +lookup/implementations
               +default/search-buffer
               consult-imenu))
  (evil-add-command-properties cmd :jump t))

(dolist (cmd '(evil-backward-section-begin
               evil-forward-section-begin
               evil-jump-item
               evil-backward-paragraph
               evil-forward-paragraph
               evil-forward-section-end))
  (evil-remove-command-properties cmd :jump))
#+end_src

#+begin_src elisp
(defadvice! u-update-last-macro-register (fn &rest args)
  "when a macro was recorded and `evil-last-register' is still `nil' (no macro was executed yet),
    set it to the just recorded macro.

  this is the sane default behaviour for 99% of the time: record a quick macro with 'qq' and
  immediately call it with '@@', instead of getting an error, getting annoyed and having to retype
  '@q' (the exact key) for the first time and then only after that you may call '@@'."
  :after #'evil-record-macro
  (when (not evil-last-register)
    (setq evil-last-register evil-last-recorded-register)))

#+end_src

- make evil's global markers persist across sessions (save state => reduce repetition, increase consistency).  this is default behaviour in vim.
#+begin_src elisp
(after! savehist
  (add-to-list 'savehist-additional-variables 'evil-markers-alist)

  (add-hook! 'savehist-save-hook
    (kill-local-variable 'evil-markers-alist)
    (dolist (entry evil-markers-alist)
      (when (markerp (cdr entry))
        (setcdr entry (cons (file-truename (buffer-file-name (marker-buffer (cdr entry))))
                            (marker-position (cdr entry)))))))

  (add-hook! 'savehist-mode-hook
    (setq-default evil-markers-alist evil-markers-alist)
    (kill-local-variable 'evil-markers-alist)
    (make-local-variable 'evil-markers-alist)))
#+end_src

~after! evil~ end
#+begin_src elisp
)
#+end_src

* global keybindings
- ~helpful-key~ and are crucial to understanding what your tools can do for you (ex: magit, dired, org-mode)
- i recommend to lookup the variable: ~M-x helpful-variable XXX-mode-map~ to get an overview of the available bindings for that mode.  find out the mode with: ~M-x describe-mode~
- always keep on exploring, learning new, efficient keybindings and break your old routines for newer, more effcient one's after evaluating wether they are faster or not.

** leaderkey
#+begin_src elisp
(setq doom-leader-key "SPC"
      doom-leader-alt-key "C-SPC"
      doom-localleader-key ","
      doom-localleader-alt-key "C-,")

(map! :leader
      "." #'vertico-repeat
      "'" #'consult-bookmark
      (:prefix "h"
               "w" #'tldr)
      (:prefix "s"
               "k" #'devdocs-lookup
               "t" #'dictionary-search)
      (:prefix "f"
               "f" #'+vertico/consult-fd-or-find)
      (:prefix "c"
               "r" #'lsp-rename
               (:prefix "'"
                        "t" #'org-babel-tangle
                        "T" #'org-babel-detangle))
      (:prefix "n"
               "g" #'org-capture-goto-last-stored))
#+end_src

** global navigation
- follows the os-consistent keymap
- these mappings are universal to all programs (shell, emacs, browser, i3) and highly frequently accessed (from any mode/file).
- workflow :: this minimalistic but powerful navigation workflow (fuzzy-find, find-file, global-marks, and find-buffer) is the most efficient & overheadfree way of navigating simultaneously between multiple different files/buffer when working within a project (low overhead when context-switching and remaining distractionfree, works from anywhere.  improves typing speed)

#+begin_src elisp
(map! :map 'override
      :nm "C-q"     #'kill-current-buffer
      :nm "C-s"     #'basic-save-buffer
      :nm "C-f"     #'find-file
      :nm "C-b"     #'consult-buffer
      :nm "C-<tab>" #'evil-switch-to-windows-last-buffer)
#+end_src

** completion & minibuffer
- completion keybindings :: use [[kbd:C-n][C-n]] for code autocompletion.  use [[kbd:C-p][C-p]] for abbreviations (which is logical since the expansion is most likely to be above the current code position)  finally, if you want to expand a snippet, or move through completion fields, use [[kbd:tab][tab]].  once autocompletion is activated, we use [[kbd:][C-n/p]] to navigate candidates.
- vertico-flat-mode :: less distracting and more focused.  it promotes finding items not by navigating via scrolling through candidates, but instead by searching.  we don't need a fancy popup everytime we want to switch to a candidate, we only want to know when the completion matches, since we already know beforehand what we are looking for.  (it is consistent with dmenu/rofi's appearance).   we use the same bindings for navigating the candidates as for completion (consistency!): [[kbd:C-n/p][C-n/p]]
- history :: [[kbd:][j, k]] is what bash's vi-mode uses by defaults, it is a good and ergonomic default.  ~evil~ expects you to use unergonomic/inaccessible [[kbd:][up, down]] by default.  (for ~comint-mode~ must use [[kbd:][ctrl]] modifier, since it is a regular buffer).
- normal mode :: we make evil-integration more sane: ~/~, ~RET~

#+begin_src elisp
  (map! :map minibuffer-mode-map
	:n "j" #'next-line-or-history-element
	:n "k" #'previous-line-or-history-element
	:i "C-n" #'completion-at-point
	:n "/"   #'previous-matching-history-element
	:n "RET" #'exit-minibuffer) ;;

  (map! :map evil-ex-search-keymap :after evil
	:n "j" #'next-line-or-history-element
	:n "k" #'previous-line-or-history-element
	:n "/" #'previous-matching-history-element
	:n "RET" #'exit-minibuffer)

  (map! :map vertico-flat-map :after vertico
	:n "j" #'next-line-or-history-element
	:n "k" #'previous-line-or-history-element
	:i "C-n" #'next-line-or-history-element
	:i "C-p" #'previous-line-or-history-element
	:n "RET" #'vertico-exit
	:n "/"   #'previous-matching-history-element)

  (map! :map vertico-map
	:im "C-w" #'vertico-directory-delete-word ;; HACK :: must bind again (smarter C-w)
	:im "C-d" #'consult-dir
	:im "C-f" #'consult-dir-jump-file)

  (map! :map company-mode-map :after company
	:i "C-n" #'company-complete)

  (map! :map comint-mode-map :after comint
	:n "C-k" #'comint-previous-input
	:n "C-j" #'comint-next-input
        ;; respect evil's bindings!
        :n "C-n" #'evil-paste-pop
        :n "C-p" #'evil-paste-pop-next
	:n "C-/" #'comint-history-isearch-backward-regexp)
#+end_src

in search/replace minibuffers we want C-p to work as in evil buffer's: to expand matches of the buffer.  C-n is still mapped to 'minibuffer-complete'.  this allows you to eg. quickly replace the symbol at 'point'.
#+begin_src elisp
(setq evil-complete-previous-minibuffer-func
      #'(lambda () (apply evil-complete-previous-func
			  '(1)))) ;; HACK :: '(1) since evil-complete-previous-func expects an arg.
#+end_src

** editing
goal :: make vim's bindings even more mnemonic/sane/sensible/efficient and improve consistency of implementation.
- useless default mappings :: remap underused/useless keys to statistically frequently used commands.
- fundamentals :: we don't change fundamental bindings of vi(m), we improve on them, as to retain muscle memory and consistency in other applications (eg. ~viper-mode~, vim emulations).
- C-j :: inverse of: ~J~, ~electric-newline-and-indent~.  this is really convenient to eg. split function arguments onto newlines.

#+begin_src elisp
(map! :after evil
      :nmv "C-i" #'better-jumper-jump-forward ;; HACK :: fix overridden binding

      ;; more sensible than `C-x/C-a', `+-' in vim is useless
      :n "+"    #'evil-numbers/inc-at-pt
      :n "-"    #'evil-numbers/dec-at-pt
      :n "g+"   #'evil-numbers/inc-at-pt-incremental
      :n "g-"   #'evil-numbers/dec-at-pt-incremental

      :n "g<"   #'evil-lion-left
      :n "g>"   #'evil-lion-right)

(define-key! [remap electric-newline-and-maybe-indent] #'newline-and-indent) ;; always try to indent!

(define-key key-translation-map (kbd "C-h") (kbd "DEL")) ;; HACK :: simulate `C-h' as backspace consistently (some modes override it to `help').
#+end_src

- note :: operators ~dd~, etc. still operate on the whole line (intended behaviour).
- we use long lines in prose (eg: org) and only wrap it visually (since it makes sense that the text is a continous line, when it is eg. an org item instead of hard-formatting it with ~gw~).
#+begin_src elisp
(define-key! [remap evil-next-line] #'evil-next-visual-line)
(define-key! [remap evil-previous-line] #'evil-previous-visual-line)
#+end_src


*** surround
- s/S :: vim's ~s, S~ is useless, since they are duplicates of: ~x, C~.  we introduce a powerful operator: ~evil-surround~.
  - readme: https://github.com/emacs-evil/evil-surround
#+begin_src elisp
(map! :after evil
      :n "s"    #'evil-surround-region
      :n "S"    #'evil-Surround-region)

(add-to-list 'evil-surround-pairs-alist '(?` . ("`" . "`")))
#+end_src

*** embrace emacs
- don't use vim's commandline: ~evil-ex~, instead just use emacs ~M-x~.  this introduces and additional layer of unneccessary complexity.  we use only the vim-motions, for all other things, emacs tools are more powerful.
  - :%s/ :: use emacs-native ~query-replace-regex~ instead, which is more interactive, powerful and flexible than vim's replacement.  it has undo, navigating matches, and can even transfor the match using arbitrary lisp code (see help: ~query-replace-regex~).
    - tip :: use ~C-r C-w/C-a~ to insert the inside-word/around-word under point in the main-buffer (vim feature).
  - :g :: use emacs ~reverse-region~, ~delete-lines~ and macros.
  - other commands such as ~:w~, ~:q~, ~:b~, ~:e~ etc. should be executed more ergonomically/efficiently by top-level keybindings (using [[kbd:][ctrl]]) anyways.
- Q ::   ~query-replace~ needs to be easily accessible (used all the time for renaming var's etc.) so it gets a top level binding and has directional forward/backward mapping like vim's: ~/?~.  (same as in ~viper-mode~)
- [remap] :: use `remap' to replace function with enhanced ones that have the same functionality (thus keeping the binding's consistency).

#+begin_src elisp
(define-key! [remap evil-ex] #'execute-extended-command)

(map! :after evil
      :n "Q" #'query-replace-regexp)
#+end_src

- get feedback when ~query-replacing~ (since we don't use evil's ~:s/~, but instead emac's native ~query-replace-regexp~)
#+begin_src elisp
(global-anzu-mode)
(define-key! [remap query-replace] #'anzu-query-replace)
(define-key! [remap query-replace-regexp] #'anzu-query-replace-regexp)
#+end_src


*** no visual modes
- after spending considerable amounts of time using emacs with ~viper-mode~ (~vi~ has no visual mode), i came to the conclusion that using ~visual-mode~ in ~vim~ actually encourages less efficient behaviour (manually selecting text even though a motion would have been more efficient).
- you are faster & more efficient enforcing the usage of motions, prefix-number commands and ~evil-repeat~.  instead of visual line mode, use a number prefix argument for ~dd, yy, cc~.  if you can't use a textobject (eg: braces, word, paragraph, sentence...).  just use ~<operator>~ + ~incsearch~ to act upto the position that you want.  (eg: ~d /~)
- this enforces you to use vim more efficiently.  additionally it comes with the benefit of making your workflow more compatible if you are working on a different setup without doom, and only vanilla emacs+viper-mode (or just ~vi~ on a server) is available.
- if you absolutely must use a visual selection, you can use [[kbd:][C-space]] (emacs binding).
- to paste over some text in visual mode, you just delete the region, then paste and use [[kbd:][C-p]] ~evil-paste-pop~ to insert what you originally yanked.

#+begin_src elisp
(define-key! [remap evil-visual-char] #'ignore)
(define-key! [remap evil-visual-line] #'ignore)
#+end_src

** harpoon
- when you are in a codebase/project, of no matter what size, this is the msot efficient way of navgating the files/buffers you find yourself alternating between.  this is for when ~switch-to-buffer~, and fuzzy-finding are just too many keystrokes and repetetively used and ~evil-switch-to-windows-last-buffer~ just isn't enough, since you need to alternate between more than 2 file.
- you are restrained to 4 files since that is all you'll need and generally, if you have more than that, you have too much mental overhead remembering which files are where, when switching and you should reprioritize your marks.  (4 seem's to be generally the limit for me for which i can subconsiously switch back and forth inbetween)
- we use [[kbd:][SPC m]] and [[kbd:][M]] since harpoon marks are conceptually similar to vim marks.
#+begin_src elisp
(use-package! harpoon
  :config
  (map! :map 'override
        :nm "M-1" #'harpoon-go-to-1
        :nm "M-2" #'harpoon-go-to-2
        :nm "M-3" #'harpoon-go-to-3
        :nm "M-4" #'harpoon-go-to-4
        :nm "M" #'harpoon-add-file) ;; quickly add file to harpoon (big brother of vims: 'm')

  (map! :leader "m" #'harpoon-toggle-file) ;; manage harpoon candidates

  (map! :map harpoon-mode-map :after harpoon
        :nm "q" #'kill-current-buffer) ;; exit like in help, magit, dired...

  (setq-hook! 'harpoon-mode-hook display-line-numbers t)) ;; show abs. line numbers to indicate the bindings.
#+end_src

* occur: emacs interactive grep
- occur :: use it like grep, to compactly view only maching lines.  additionally it is a powerful interactive search & replace tool.  (edit the matching lines buffer interactively, for more power combined the editing using macros).
#+begin_src elisp
(map! :map occur-mode-map :after replace
      :n "q" #'quit-window) ;; consistent with other read-only modes (magit, dired, docs...)

(map! :after evil
      :nm "g/"  #'occur)
#+end_src

* dired
- avoid using integrated filemanagers and manually navigating directory structures (such as dired / ranger / thunar) whenever possible (and dont even dare to suggest a gui file manager...).
- if think you need a sidebar type file explorer, you are doing something terribly inefficient in your workflow.
- use a fileexplorer mostly for getting an overview of a directory and to manipulate files in that directory.
- it's more efficient, faster and extensible using search & completion tools, such as emacs: find-file, fuzzy finding and using harpoon-marks, global-marks and bookmarks for switching to other directories and files.
- ditch spamming [[kbd:hjkl][hjkl]] to navigate nested directories fore directly goto to the file you are looking for.

#+begin_src elisp
(after! dired
  ;; make it more visually minimal, toggle all the details if needed explicitly.
  (add-hook! 'dired-mode-hook '(dired-hide-details-mode dired-omit-mode))
  (add-hook! 'wdired-mode-hook (dired-hide-details-mode -1)) ;; prevent hidden edits

  ;; open graphical files externally
  (setq dired-open-extensions (mapcan (lambda (pair)
                                        (let ((extensions (car pair))
                                              (app (cdr pair)))
                                          (mapcar (lambda (ext)
                                                    (cons ext app))
                                                  extensions)))
                                      '((("mkv" "webm" "mp4" "mp3") . "mpv")
                                        (("pdf")                    . "zathura")
                                        (("gif" "jpg" "png")        . "feh")
                                        (("docx" "odt" "odf")       . "libreoffice")))
        dired-recursive-copies 'always
        dired-recursive-deletes 'always
        dired-no-confirm '(uncompress move copy)
        dired-omit-files "^\\..*$")

  (define-key! [remap dired-find-file] #'dired-open-file)) ;; try dired-open fn's (no success => call: `dired-find-file')
#+end_src

** dired/keybindings
- filemanagers :: avoid using integrated filemanagers (such as dired / ranger / lf) whenever possible replace them with shell commands and fuzzy-finding (in project/root/recentfiles)
- in most cases it is more extensible and faster using tools such as emacs find-file in combination with fuzzy finding and using global bookmarks for frequently used projects/files.
- create new files/dir's using ~find-file~ instead of ~dired-create-empty-file~ (inserts filetemplate properly)
#+begin_src elisp
(map! :map dired-mode-map :after dired
      :m "h" #'dired-up-directory) ;; navigate using hjkl

(map! :map dired-mode-map :localleader :after dired-x
      :desc "dired-hide-details" "h" (cmd! (call-interactively #'dired-omit-mode)
                                           (call-interactively #'dired-hide-details-mode))
      "a" #'u-dired-archive)
#+end_src

** archive file
- archive all things that were once written or created by you (instead of deleting them) => digital content cost's little to no space.  and you will be grateful later in life to have recorded data (that can be analyzed & crunched) what you were thinking and how you configured your tools etc...
- this ensures a predictable and consistent archiving scheme (archive to original path under archive)
#+begin_src elisp
(defvar u-archive-dir "~/Archive/")

(defun u-dired-archive ()
  "`mv' marked file/s to: `u-archive-dir'/{relative-filepath-to-HOME}/{filename}"
  (interactive)

  (mapc (lambda (file)
          (let* ((dest (file-name-concat u-archive-dir
                                         (format "%s_archived_%s.%s"
                                                 (file-name-sans-extension (file-relative-name file "~/"))
                                                 (format-time-string "%F_T%H-%M-%S")
                                                 (file-name-extension file))))
                 (dir (file-name-directory dest)))

            (unless (file-exists-p dir)
              (make-directory dir t))
            (rename-file file dest 1)))
        (dired-get-marked-files nil nil))

  (revert-buffer))
#+end_src

* org
#+begin_src elisp
(after! org
#+end_src

 - syntax :: for lists, be consistent and only use: ~-~ for unordered lists (never ~*, +~), and for ordered lists, use ~1.~, ~a.~ (never ~1)~ or ~a)~)
 - ui ::
   - ensure all headings and faces have the same heigth => better overview & less overhead
   - visually distinctualize headings & keywods from the rest of the text with coloring and bold
   - like in code, everything is code/data => also org mode / latex documents.
   - its not about some fancy looking thing, its about the internals, the quality of the data, not the presentation.

** tags
- Always use tags to specify what a todo-item belongs to & never write it in the todo-name | not: ~TODO uni math assignment [2]~ => instead: ~TODO assignment [2] :uni:math:assignments:~
- use tags with path hierarchy & inheritance to signal to which project / topic / subject the task belongs to have a clear overview in the agenda.
  - use the tags from more general -> specific (eg: ~:fitness:endurance:running:ultrarunning:~, only use more specific tags if the note actually specifically talks about them, otherwise use the more general one)
- mark top level subject with tag
- ex: ~:cs:math:statisticts:exercise~ => filter: outstanding ~exercises~ of math.
- ex: ~:cs:math:statisticts:question:~ => filter: outstanding ~questions~
- ex: ~:personal:youtube:video~
- ex: ~:personal:book:fiction~
- ex: ~- [ ] change keybindings :config:emacs:~
- never mention the location/project of the task, instead specify it as a task hierarchy (scope resolution, flexible querying) (same as in programming var-names should never include the typee / functions don't have module-name in their name, instead the location is specified via module)
- ~[ ] fix bugs in emacs config for the org mode module~ => ~[ ] fix bugs :config:emacs:org:~
- this is a clear and highly structured, data orientated approach.  (all the benefits of data follow: querying, extensibility...)
- org-agenda :: filter for all headings with that specific tag across all files (eg.  sort class specific todos w tags)

** options
- archive all done tasks in current file/headings with org-agenda bulk action.
- each file gets its own entry in ~~/archive/org~
#+begin_src elisp
(add-hook! 'org-mode-hook '(visual-line-mode
                            org-fragtog-mode
                            rainbow-mode
                            laas-mode
                            +org-pretty-mode
                            org-appear-mode))

(add-hook! 'org-mode-hook :local
  (add-to-list 'evil-surround-pairs-alist '(?~ . ("~" . "~"))))

(setq-hook! 'org-mode-hook warning-minimum-level :error) ;; prevent frequent popups of *warning* buffer

(setq org-use-property-inheritance t
      org-reverse-note-order t
      org-startup-with-latex-preview t
      org-startup-with-inline-images t
      org-startup-indented t
      org-startup-numerated t
      org-startup-align-all-tables t
      org-list-allow-alphabetical t
      org-tags-column 0
      org-fold-catch-invisible-edits 'smart
      org-refile-use-outline-path 'full-file-path
      org-refile-allow-creating-parent-nodes 'confirm
      org-use-sub-superscripts '{}
      org-fontify-quote-and-verse-blocks t
      org-fontify-whole-block-delimiter-line t
      doom-themes-org-fontify-special-tags t
      org-ellipsis "…"
      org-num-max-level 3
      org-hide-leading-stars t
      org-appear-autoemphasis t
      org-appear-autosubmarkers t
      org-appear-autolinks t
      org-appear-autoentities t
      org-appear-autokeywords t
      org-appear-inside-latex nil
      org-hide-emphasis-markers t
      org-pretty-entities t
      org-pretty-entities-include-sub-superscripts t
      org-list-demote-modify-bullet '(("-"  . "-")
                                      ("1." . "a."))
      org-blank-before-new-entry '((heading . nil)
                                   (plain-list-item . nil))
      org-src-ask-before-returning-to-edit-buffer nil)

(add-hook! 'org-src-mode-hook (flycheck-mode -1)) ;; flycheck full of error's, since it only reads partial buffer.
#+end_src

#+begin_src elisp
(defadvice! u-insert-newline-above (fn &rest args)
  "pad newly inserted heading with newline unless is todo-item.

  since i often have todolists , where i don't want the newlines.  newlines are for headings that have a body of text."
  :after #'+org/insert-item-below
  (when (and (org-at-heading-p)
             (not (org-entry-is-todo-p)))
    (+evil/insert-newline-above 1)))

(defadvice! u-insert-newline-below (fn &rest args)
  :after #'+org/insert-item-above
  (when (and (org-at-heading-p)
             (not (org-entry-is-todo-p)))
    (+evil/insert-newline-below 1)))
#+end_src

** symbols
- clean up symbols with unicode => more clean, minimalist, easier to read.
- use '●' for heading, '─' for list for unambiguity and a minimalist look.  org heading level is differentiated by indentation and face.
#+begin_src elisp
(add-hook! 'org-mode-hook '(org-superstar-mode
                            prettify-symbols-mode))

(setq org-superstar-headline-bullets-list "●")

(setq org-superstar-item-bullet-alist '((?- . "─")
                                        (?* . "─") ;; NOTE :: asteriks are reserved for headings only (don't use in lists) => no unambigiuity
                                        (?+ . "⇒")))

(appendq! +ligatures-extra-symbols '(:em_dash       "—"
                                     :ellipses      "…"
                                     :arrow_right   "→"
                                     :arrow_left    "←"
                                     :arrow_lr      "↔"))

(add-hook! 'org-mode-hook
  (appendq! prettify-symbols-alist '(("--"  . "–")
                                     ("---" . "—")
                                     ("->" . "→")
                                     ("=>" . "⇒")
                                     ("<=>" . "⇔"))))
#+end_src

** org/keybindings
#+begin_src elisp
(map! :map org-mode-map :after org
      :localleader
      "\\" #'org-latex-preview
      ","  #'org-ctrl-c-ctrl-c
      "z"  #'org-add-note
      :desc "toggle-checkbox" "["  (cmd! (let ((current-prefix-arg 4))
                                           (call-interactively #'org-toggle-checkbox))))
#+end_src

** babel
#+begin_src elisp
(setq org-babel-default-header-args '((:session  . "none")
                                      (:results  . "replace")
                                      (:exports  . "code")
                                      (:cache    . "no")
                                      (:noweb    . "yes")
                                      (:hlines   . "no")
                                      (:tangle   . "no")
                                      (:mkdirp   . "yes")
                                      (:comments . "link"))) ;; important for when wanting to retangle
#+end_src

** clock
#+begin_src elisp
(setq org-clock-out-when-done t
      org-clock-persist t
      org-clock-into-drawer t)
#+end_src

** task states
- these are task states are used for personal daily organization & studying at university (keeping track of lectures, assignments, events)
- using symbols instead of words to represent states => less clutter, more concise, readeable & structured.
- order them with priorities to assign order of execution if there are many tasks
- when changing state add a note to the state-change if needed
- use ~org-add-note~ for leaving comments on the article.  (eg: thougths when revisiting the article at a later time.)
- reflecting
- log/track
- progress
- time
- performance
- stats
- steps taken to complete task
- reason: why task was moved to that state
- seamlessly pick up work at a later time
- ~[ ] watch lecture~ -> ~[-] watch lecture~ | annotate time: where the task was last left off: "01:25:23h"

~[@]~: event
- useful if you have to take steps after the event

~[ ]~: outstanding item

~[?]~: optional
- non-compulsory item

~[-]~: in-progress / started
- item being worked on

~[=]~: on-hold
- unfinished item waiting for smthing, before can be finished / continued

~[&]~: review
- review item (ex: correct assignment, revise meeting notes).
- post completion: review performance, asess effort...

~[>]~: delegated/assigned to someone
- waiting for it to be finished to resume
- check up on them

~[\]~: cancelled
  - no longer neccessary

~[x]~: completed

we prompt for a note on the task when chaning state to either: on-hold, in-prog or delegated, since we want to leave a comment on how work should be resumed next time the task is being revisited (eg. page number of a book, who to check in with after delegating the task, exercise that is to be worked on)
#+begin_src elisp
;; ! => save timestamp on statchange
;; @ => save timestamp on statchange & add note associated with change to LOG.
(setq org-todo-keywords '((sequence
                           "[ ](t)"
                           "[@](e)"
                           "[?](?!)"
                           "[-](-@)"
                           "[>](>@)"
                           "[=](=@)"
                           "[&](&@)"
                           "|"
                           "[x](x!)"
                           "[\\](\\!)")))

(setq org-todo-keyword-faces '(("[@]"  . (bold +org-todo-project))
                               ("[ ]"  . (bold org-todo))
                               ("[-]"  . (bold +org-todo-active))
                               ("[>]"  . (bold +org-todo-onhold))
                               ("[?]"  . (bold +org-todo-onhold))
                               ("[=]"  . (bold +org-todo-onhold))
                               ("[&]"  . (bold +org-todo-onhold))
                               ("[\\]" . (bold org-done))
                               ("[x]"  . (bold org-done))))
#+end_src

- Log to drawer: ~LOG~
- Make org-log messages more data orientated and functional.  (less verbose and literate, easier to parse)
#+begin_src elisp
(setq org-log-done 'time
      org-log-repeat 'time
      org-todo-repeat-to-state "[ ]"
      org-log-redeadline 'time
      org-log-reschedule 'time
      org-log-into-drawer "LOG") ;; more concise & modern than: LOGBOOK

(setq org-priority-highest 1
      org-priority-lowest 3)

(setq org-log-note-headings '((done        . "note-done: %t")
                              (state       . "state: %-3S -> %-3s %t") ;; NOTE :: the custom task-statuses are all 3- wide
                              (note        . "note: %t")
                              (reschedule  . "reschedule: %S, %t")
                              (delschedule . "noschedule: %S, %t")
                              (redeadline  . "deadline: %S, %t")
                              (deldeadline . "nodeadline: %S, %t")
                              (refile      . "refile: %t")
                              (clock-out   . "")))
#+end_src

** capture templates
- create capture-templates for organization on a per project basis, ex: university, personal, work..
- capture templates are used to collect & capture notes, events, tasks and templates; structured, tagged, sorted into a specific files.
- this ensures information based data is consistently captured.
- this is very customizeable and allows you to setup complex templates and should be used whenever you want to log data / repeatatively track things, or want to capture structured data with different entries consistently (eg: literature to track reading process).
- use the heading: ~inbox~ for collecting the captured tasks => can get messy, and can be refactored out of inbox into more structure if neccessary.
- for each project there is a separate folder (relative to org-dir) with files:
- agenda :: all tasks (todos, completed etc) and events (physical appointments)
- notes :: thoughts, exploration -> to study, to remember, to refactor
- set tags for entire file in the document-header with ~#+filetags: :proj:~
- motivation :: this scheme of =agenda/notes= is used to have a structured and consistent approach for generic projects-management.
- prepending :: if recent item's are of higher relevance
- appending :: for hierarchical order eg. book-quotes ordered from begin -> end

- implemented is a structured approach for generic projects, all using the same (but relative to project) paths and capture-templates.

#+begin_src elisp
(setq org-directory "~/Documents/org/")

(defvar u-journal-dir (file-name-concat "~/Documents/journal/")
  "dir for daily captured journal files")

(defvar u-literature-dir "~/Documents/literature"
  "literature sources and captured notes")

(defvar u-literature-notes-dir (file-name-concat u-literature-dir "notes/")
  "note files for each literature source")

(defvar u-wiki-dir "~/Documents/wiki/"
  "personal knowledge base directory :: cohesive, structured, standalone articles/guides.
(blueprints and additions to these articles are captured into 'org-directory/personal/notes.org',
and the later reviewed and merged into the corresponding article of the wiki.")

(defvar u-u-doct-projects-default-templates '(u-doct-projects-task-template
                                              u-doct-projects-event-template
                                              u-doct-projects-note-template))

(defvar u-doct-projects `(("cs" :keys "c"
                           :templates ,u-u-doct-projects-default-templates
                           :children (("ti"   :keys "t")
                                      ("an2"  :keys "a")
                                      ("ph1"  :keys "p")
                                      ("spca" :keys "s" :templates (u-doct-projects-cc-src-template))
                                      ("nm"   :keys "n" :templates (u-doct-projects-cc-src-template))))
                          ("personal" :keys "p" :templates ,u-u-doct-projects-default-templates)
                          ("config"   :keys "f" :templates ,u-u-doct-projects-default-templates))
  "same syntax as doct,  except for the key-value-pair: `:templates LIST`,
 where LIST is a list of functions with signature: `(PATH) -> VALID-DOCT-TEMPLATE`
 where PATH is to be generated by 'u-doct-projects-file'
 where TEMPLATE is a valid 'doct-capture-template'.
':templates' is inherited by the parent-group and if present in a childgroup it appends the
   additionally defined templates.")

(defun u-doct-journal-file (&optional time)
  "returns a structured filename based on the current date.
eg: journal_2024-11-03.org
TIME :: time in day of note to return. (default: today)"
  (file-name-concat u-journal-dir
                    (format "journal_%s.org"
                            (format-time-string "%F"
                                                (or time
                                                    (current-time))))))

(defun u-doct-projects-file (type path)
  "TYPE :: 'agenda | 'notes"
  (file-name-concat org-directory
                    path (format "%s.org"
                                 (symbol-name type))))

(defun u-doct-projects-task-template (path)
  (list "task"
        :keys "t"
        :file (u-doct-projects-file 'agenda path)
        :headline "inbox"
        :prepend t
        :empty-lines-after 1
        :template '("* [ ] %^{title}%?")))

(defun u-doct-projects-event-template (path)
  (list "event"
        :keys "e"
        :file (u-doct-projects-file 'agenda path)
        :headline "events"
        :prepend t
        :empty-lines-after 1
        :template '("* [@] %^{title}%?"
                    "%^T"
                    ":PROPERTIES:"
                    ":REPEAT_TO_STATE: [@]" ; NOTE :: in case is made repeating
                    ":location: %^{location}"
                    ":material: %^{material}"
                    ":END:")))

(defun u-doct-projects-note-template (path)
  (list "note"
        :keys "n"
        :file (u-doct-projects-file 'notes path)
        :prepend t
        :empty-lines-after 1
        :template '("* %^{title} %^g"
                    ":PROPERTIES:"
                    ":created: %U"
                    ":END:"
                    "%?")))

(defun u-doct-projects-cc-src-template (path)
  "for quickly implementing/testing ideas (like a scratchpad, but you have all your experimentations
  in a single literate document).  choose either c or c++"
  (list "note: src cc"
        :keys "s"
        :file (u-doct-projects-file 'notes path)
        :prepend t
        :empty-lines 1
        :template '("* %^{title} :%^{lang|C|C|cpp}:"
                    ":PROPERTIES:"
                    ":created: %U"
                    ":END:"
                    "#+begin_src %\\2"
                    "<<%\\2_header>>" ;; <<header>> is org-babel's `:noweb` syntax and the named org-src-block: `c_header` (or cpp_header) (which must be present in the targetfile.  depending on wether the project uses C or cpp it is different) and should contains stuff like `#include <iostream>' that is basically needed for every single snippet.
                    ""
                    "int main() {"
                    "        %?"
                    "}"
                    "#+end_src")))

(defun u-doct-projects-expand-templates (projects &optional inherited-templates parent-path)
  "PROJECTS :: `u-doct-projects'
PARENT-PATH :: nil (used for recursion) "
  (mapcar (lambda (project)
            (let* ((tag (car project))
                   (props (cdr project))
                   (key (plist-get props :keys))
                   (self `(,tag :keys ,key))
                   (children (plist-get props :children))
                   (templates (append inherited-templates (plist-get props :templates)))
                   (path (file-name-concat parent-path tag)))
              (append self
                      (if children
                          ;; HAS CHILDREN => is project-node => recursivly expand children
                          (list :children
                                (append (u-doct-projects-expand-templates (list self)
                                                                          templates)
                                        (u-doct-projects-expand-templates children
                                                                          templates
                                                                          path)))

                        ;; NO CHILDREN => is leaf-node => instantiate templates
                        (list :children (mapcar (lambda (fn-sym)
                                                  (funcall fn-sym path))
                                                templates))))))
          projects))

(setq org-capture-templates
      (doct `(;; PROJECT TEMPLATES
              ,@(u-doct-projects-expand-templates u-doct-projects)

              ;; NON-PROJECT TEMPLATES
              ("journal"
               :keys "j"
               :file (lambda () (u-doct-journal-file))
               :title (lambda ()
                        (downcase (format-time-string "journal: %A, %e. %B %Y")))

               :children (("journal init"
                           :keys "j"
                           :type plain
                           :template  ("#+title:  %{title}"
                                       "#+author: %(user-full-name)"
                                       "#+email:  %(message-user-mail-address)"
                                       "#+date:   %<%F>"
                                       "#+filetags: :journal:"
                                       ""
                                       "* goals"
                                       "- [ ] %?"
                                       ""
                                       "* agenda"
                                       "** [ ] "
                                       ""
                                       "* notes"))

                          ("note"
                           :keys "n"
                           :headline "notes"
                           :prepend t
                           :empty-lines-after 1
                           :template ("* %^{title}"
                                      ":PROPERTIES:"
                                      ":created: %U"
                                      ":END:"
                                      "%?"))

                          ("yesterday review"
                           :keys "y"
                           :unnarrowed t
                           :file (lambda ()
                                   (u-doct-journal-file (time-subtract (current-time)
                                                                     (days-to-time 1))))
                           :template ("* gratitude"
                                      "- %?"
                                      ""
                                      "* reflection"
                                      "-"))))

              ("literature"
               :keys "l"
               :file (lambda () (read-file-name "file: " u-literature-notes-dir))
               :children (("add to readlist"
                           :keys "a"
                           :file ,(file-name-concat u-literature-dir "readlist.org")
                           :headline "inbox"
                           :prepend t
                           :template ("* [ ] %^{title}"))

                          ("init source"
                           :keys "i"
                           :file (lambda ()
                                   (file-name-concat u-literature-notes-dir
                                                     (concat (replace-regexp-in-string " "
                                                                                       "_"
                                                                                       (read-from-minibuffer "short title: "))
                                                             ".org")))
                           :type plain
                           :template ("#+title:  %^{full title}"
                                      "#+author: %(user-full-name)"
                                      "#+email:  %(message-user-mail-address)"
                                      "#+date:   %<%F>"
                                      "#+filetags: :literature:%^g"
                                      ""
                                      "* [-] %\\1%?"
                                      ":PROPERTIES:"
                                      ":title:  %\\1"
                                      ":author: %^{author}"
                                      ":year:   %^{year}"
                                      ":type:   %^{type|book|book|textbook|book|paper|article|audiobook|podcast}"
                                      ":pages:  %^{pages}"
                                      ":END:")
                           :hook (lambda () (message "change task-state in readlist.org!")))

                          ("quote"
                           :keys "q"
                           :headline "quotes"
                           :empty-lines-before 1
                           :template ("* %^{title} [pg: %^{page}]"
                                      ":PROPERTIES:"
                                      ":created: %U"
                                      ":END:"
                                      "#+begin_quote"
                                      "%?"
                                      "#+end_quote"))

                          ("note: literary"
                           :keys "l"
                           :headline "literature notes"
                           :empty-lines-before 1
                           :template ("* %^{title} [pg: %^{page}] %^g"
                                      ":PROPERTIES:"
                                      ":created: %U"
                                      ":END:"
                                      "%?"))

                          ("note: transient"
                           :keys "t"
                           :headline "transient notes"
                           :empty-lines-before 1
                           :template ("* %^{title} %^g"
                                      ":PROPERTIES:"
                                      ":created: %U"
                                      ":END:"
                                      "%?"))

                          ("summarize"
                           :keys "s"
                           :headline "summary"
                           :unnarrowed t
                           :type plain
                           :template ("%?")
                           :hook (lambda ()
                                   (message "change task-state!: TODO -> DONE")))))))) ;; in order to log finishing date
#+end_src

** agenda
- multi-day-todo-events: add multiple timestamps on the same line => same task shows scheduled on different days.  ex:
- track which university lectures you have watched & reviewed.  => even if they are spread out onto multiple days => log all completions / review-notes under the same task.

#+begin_src elisp
(add-hook! 'org-agenda-mode-hook #'org-super-agenda-mode)

(setq org-archive-location (file-name-concat u-archive-dir "org" "%s::") ;; NOTE :: archive based on relative file path
      org-agenda-files (append
                        (when (file-exists-p org-directory)
                          (directory-files-recursively org-directory
                                                       org-agenda-file-regexp
                                                       t))
                        (list (u-doct-journal-file)
                              (u-doct-journal-file (time-subtract (current-time)
                                                                (days-to-time 1))))) ;; include tasks from {today's, yesterday's} journal's agenda
      org-agenda-skip-scheduled-if-done t
      ;; org-agenda-sticky t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-tags-column 0
      org-agenda-block-separator ?─
      org-agenda-breadcrumbs-separator "…"
      org-agenda-compact-blocks nil
      org-agenda-show-future-repeats nil
      org-deadline-warning-days 3
      org-agenda-time-grid nil
      org-capture-use-agenda-date t)
#+end_src

#+begin_src elisp
(defadvice! u-add-newline (fn &rest args)
  "Separate dates in 'org-agenda' with newline."
  :around #'org-agenda-format-date-aligned
  (concat "\n" (apply fn args) ))
#+end_src

org-agenda by default is a clusterfuck.  this will clean it up: cleanly align everything into columns & group items.
+ achieve a nce and consistent readeable data-orinetated view
+ all task-states have the same length, otherwise there is no task-keyword alignment.
+ Set more concise & informing ~deadline~ & ~scheduled~ strings
#+begin_src elisp
(setq org-agenda-todo-keyword-format "%-3s"
      org-agenda-scheduled-leaders '(""
                                     "<< %1dd") ;; NOTE :: unicode is not fixed width => breaks formatting => cannot use it.
      org-agenda-deadline-leaders '("─────"
                                    ">> %1dd"
                                    "<< %1dd")
      org-agenda-prefix-format '((agenda . "%-20c%-7s%-7t") ;; note all columns separated by minimum 2 spaces
                                 (todo   . "%-20c%-7s%-7t")
                                 (tags   . "%-20c%-7s%-7t")
                                 (search . "%-20c%-7s%-7t")))
#+end_src

** org roam
#+begin_src elisp
(setq org-roam-directory u-wiki-dir)
#+end_src

** end org
- end of org section started with: ~after! org~
#+begin_src elisp
)
#+end_src

* dictionary
#+begin_src elisp
(after! dictionary
  (setq dictionary-server "dict.org"
        dictionary-default-dictionary "*"))
#+end_src

* devdocs
i always look up documentation/manuals within emacs.  (only if it's not sufficient do i resort to the browser/chatgpt)
#+begin_src elisp
(after! devdocs
  (setq devdocs-window-select t))

(setq-hook! 'java-mode-hook devdocs-current-docs '("openjdk~17"))
(setq-hook! 'ruby-mode-hook devdocs-current-docs '("ruby~3.3"))
(setq-hook! 'c++-mode-hook devdocs-current-docs '("cpp" "eigen3"))
(setq-hook! 'c-mode-hook devdocs-current-docs '("c"))
#+end_src

* whisper: transcription
we often formulate notes using transcription for speed and ergonomics.
always use ~evil-define-operator~ for ~evil-mode~ integration when defining routines to act on text.
#+begin_src elisp
(evil-define-operator u-reformat-prose (beg end)
  "we write all lowercase, all the time (to make the text more monotone, such that it's value will
speak more for it's self).  using the technical document convention of double space full stops for
legibility."
  (save-excursion
      (downcase-region beg end)
      (repunctuate-sentences t beg end)))

(add-hook! 'whisper-after-transcription-hook (u-reformat-prose (point-min) (point-max)))

(map! :leader "X" #'whisper-run)
#+end_src

* vertico: minibuffer completion
- i want a minimalist unobtrusive menu on the bottom of the frame, not a huge window popup disturbing my focus and workflow.
- this is consistent with rofi theme (or dmenu if using that).
#+begin_src elisp
(vertico-flat-mode)
#+end_src

* nov: ebooks
- uses variable pitch mode
#+begin_src elisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (setq nov-variable-pitch t ;; serif for prose reading
        nov-text-width t) ;; used visual-line-mode and visual-fill-column mode to visually wrap line.
  (advice-add 'nov-render-title :override #'ignore) ;; using modeline...

  (map! :map (nov-mode-map nov-button-map)
        "SPC" nil                     ;; never override leader-mode
        "C-SPC" nil                   ;; never override leader-mode
        :n "q" #'kill-current-buffer  ;; consistent with other read-only modes (magit, dired, docs...)
        :n "o" #'nov-goto-toc         ;; o => outline, which is more mnemonic (consistent with pdf-view-mode, info-mode, evil: 'imenu' outline when in code)

        ;; next/previous page
        :n "<next>" #'nov-scroll-up
        :n "<prior>" #'nov-scroll-down)

  (add-hook! 'nov-mode-hook
    (visual-fill-column-mode)
    (visual-line-mode)

    (setq-local next-screen-context-lines 0 ;; no confusing page overlaps, always start reading on the first visible line of the next page
                line-spacing 2) ;; padding increases focus on current line for long prose text.

    (setq-local global-hl-line-mode nil)  ;; HACK :: need to unset, instead of using a hook
    (hl-line-mode -1)))
#+end_src

* company: code completion
- disable completion menu by default ::
  - i don't want company to show up and distract me when i already know exactly what i want.
  - make use of it only when you don't know the exact symbol name / function signature, or when typing overly long symbol-names becomes tedious.
  - this enforces more thoughtful coding, evaluating what the function actually does and let's you see what is really happening underneath.
  - it actually makes you faster, since it removes the mental overhead and interruption that arises from the distracting completion menu, where you will choose the option from.  greatly improves overall typing speed.
  - it makes coding more raw, distractionfree, and overall more enjoyeable
#+begin_src elisp
(after! company
  (setq company-minimum-prefix-length 0
        company-idle-delay nil ;; only show menu when explicitly activated
        company-show-quick-access t))
#+end_src

* yas: snippets
- nested snippets ared good
#+begin_src elisp
(setq yas-triggers-in-field t)
#+end_src

* file templates
in each new file systematically insert heading metadata (as comments) with the following template
- append more neccessary info if needed (ex: ~dependencies:~)
#+begin_example
# ---
# title:  file metadata
# author: emil lenz
# email:  emillenz@protonmail.com
# date:   2024-01-06
# notes:
# - outlines file-metadata template, to be inserted at top of every file systematically.
# ---
#+end_example

- title :: full title of document.
- author :: document creator/"owner".
- email :: author's email
- for contacting him with question's / reaching out.
- date :: date of file creation, iso8601 format.
- track your coding/writing progress over the years and just generally it is important to document the timing of things, to analyze/order/reconstruct them.
- info :: short document description/summary, think of it as a docstring for the file with this the reader should know what the document is about in one line.

we automate this repetetive task using a snippets.
#+begin_src elisp
(set-file-templates!
 '(org-mode :trigger "header")
 '(prog-mode :trigger "header")
 '(makefile-gmake-mode :ignore t))
#+end_src

* lispy(ville): editing lisp in vim
- makes vim's motions dwmi in lisp modes (mainly respecting parenthesis).
#+begin_src elisp
(add-hook! '(emacs-lisp-mode-hook lisp-mode-hook) #'lispyville-mode)

;; call help on `lispyville-set-key-theme' to see the changed bindings.
(after! lispyville
  (lispyville-set-key-theme '(operators
                              insert
                              c-w
                              c-u
                              prettify
                              text-objects
                              commentary
                              slurp/barf-lispy
                              additional
                              (atom-movement t)
                              additional-insert)))
#+end_src

* shell
- to start a emacs/shell-buffer independent process, use ~nohup CMD &>/dev/null &~.
- we never use popupterminals (use async-shell command for one-off's)
#+begin_src elisp
(after! shell
  (set-lookup-handlers! 'shell-mode :documentation '+sh-lookup-documentation-handler))

(define-key! [remap +shell/toggle] #'+shell/here)
#+end_src

 normal mode by default :: 99% of the time i want to navigate the compilation/shell buffer.  (and not read stdin in insert mode))
#+begin_src elisp
(add-to-list 'evil-normal-state-modes 'shell-mode)
#+end_src
