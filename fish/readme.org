#+title:  shell rationale
#+author: emil lenz
#+email:  emillenz@protonmail.com
#+date:   2024-11-23

* anything but bash
bash is coherent with respect to the mind of certain benevolent dictator.  bash is a steaming pile of inconsistent user-unfrienly shit.  we want the best interactive features in a shell, fish has powerful features inbuilt and is consistent in its design and configuration.  (autocomplete, documentation, keybindings, aliases, etc..)
On the command line, I don't really need a full language with a repl-like interface.  I want a fast and quick way to interface with the OS.  Anything beyond that should be written in a proper language (ruby) that will inherently bring more benefits.

* scripting in ruby
a shell only exists for interactive use and running commands: launching processes/commands, interaction with the filesystem and programs (mv, cp, find, grep..).
for scripting however, anything that cannot be done in a oneliner (using && || etc.).  for example: data manipulation (JSON, etc.), conditional execution (if else), functions or the usage of variables/datastructures, you should always opt towards a proper scripting language such as ruby.  since it offer's full library support, is more extensible and maintaineable.

when writing shell commands in scripts one should always favor ~--long-flags~ over ~-l~ in order to increase code readability  and maintaineability.  this makes understanding the script for people who may not be familiar with the programs easier to understand and modify (reduce elitism in free software).

even though it may have a steeper learning curve and requires a more structured and less hacky approach to scripting.  but once fluent in it, it smoothly bridges the gap between compiled highly efficient languages such as rust or c and the interactive nature of a shell.

choosen over python since it is well designed, has a very minimal, clean, consistent syntax.  close interconnectedness with ~sh~ by running ~sh~-commands with ~``~.  i love the fact that everything is a expression (has a value).  This means, it's a extreme joy for functional programers.  Python is pretty badly designed, lots inconsistencies in syntax as well as semantics.  ruby follows the MIT philosophy of making the userinterface consistent and a joy to use.

* non interactive command guidelines
- favor ~--long-flags~ over ~-f~ in order to make the code more unambiguous (shortflags have different meaning across different programs), readeable and easier to maintain.
- additionally always use ~--key=value~ with the ~=~ over ~--key value~, since this distinguishes flag-arguments unabiguosly from key-value pairs.
